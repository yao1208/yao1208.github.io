[{"title":"EDA学习笔记","url":"/2022/09/20/EDA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"EDA技术EDA技术即是电子设计自动化技术，它由PLD技术发展而来，可编程逻辑器件PLD的应用与集成规模的扩大为数字系统的设计带来了极大的方便和灵活性，变革了传统的数字系统设计理念、过程、方法。通过对PLD技术不断地改进提高，EDA技术应运而生。\nEDA技术就是基于大规模可编程器件的，以计算机为工具，根据硬件描述语言HDL完成表达，实现对逻辑的编译化简、分割、布局、优化等目标的一门新技术，借助EDA技术，操作者可以通过利用软件来实现对硬件功能的一个描述，之后利用FPGA/CPLD才可得到最终设计结果。\nEDA技术是一门综合性学科，它打破了软件和硬件间的壁垒，代表了电子设计技术和应用技术的发展方向。缩写EDA: Electronic design automation 电子设计自动化\nFPGA: Field Programmable Gate Array 可编程逻辑门阵列\nCPLD: Complex Programmable logic device 复杂可编程逻辑器件\nVHDL: VHSIC(Very-High-Speed Integrated Circuit) Hardware Description Languag 超高速集成电路硬件描述语言\nRTL: Register Transfer Level 暂存器转移层次\nSOC: System on Chip 系统级芯片\nIP core: Intellectual Property core 知识产权核\nASIC: Application Specific Integrated Circuit 特殊应用集成电路\nVHSIC: Very-High-Speed Integrated Circuit 超高速集成电路\nSTA: Static Timing Analysis 静态时序分析\nDSP: Digital Signal Process 数字信号处理\n基础语法Verilog基本概念模块语句及其表达式Verilog的基本设计单元是“模块”(block) 。一个模块是由两部分组成的，一部分描述接口，另一部分描述逻辑功能，即定义输入是如何影响输出的。\nmodule 模块名(模块端口名表);    \t模块端口和模块功能描述endmodule\n\n模块名（标识符）的命名规则：\n标识符是用户在描述时给 标识符是用户在描述时给Verilog对象起的名字；\n\n标识符必须以字母 标识符必须以字母(a-z, A-Z) 或( _ ) 开头，后面可以是字母、数字、或( $ _ )。\n\n 最长可以是1023个字符个字符。\n\n标识符区分大小写，标识符区分大小写，sel 和SEL是不同的标识符。\n\n 模块、端口和实例的名字都是标识符。\n\n标识符要区别与关键字，这个命名规则和C语言大同小异。\n\n\n模块端口描述语句端口语句、端口信号名、端口模式：端口定义关键词一般有三种：input、output、inout，定义端口语句一般格式如下：\ninput 端口名1，端口名2，...;output 端口名1，端口名2，...;inout 端口名1，端口名2，...;input [msb:lsb]端口名1，端口名2，...;\n\n注：I/O说明也可以写在端口声明语句里。其格式如下：\nmodule 模块名(input 端口名1,input 端口名2,output 端口名3,output 端口名4… ); \n\n描述模块的逻辑功能和电路结构内部信号说明在模块内用到的和与端口有关的wire 和 reg 变量的声明。\n输入输出信号缺省时默认是wire。在always块里的指定信号，常代表触发器寄存器，如果需要中间赋值或运算，需声明成reg类型。\nreg [width-1 :0] 变量1，变量2 …；wire [width-1 : 0] 变量1，变量2 …；\n\nverilog数据常量定义：数字表达式：**&lt;位宽&gt;&lt;进制&gt;&lt;数字&gt;**‘b:二进制 4&#39;b1110 表示4位二进制数1110‘h:十六进制 8&#39;hef 4&#39;ha‘d:十进制  2&#39;d3、4&#39;d15(不能写16，4位宽最大15)等\n顶层程序调用底层module和c语言函数格式类似，通过module定义的端口传递参数，但是使用思想不同。\n模组类名 实例名（端口变量）\n端口变量尽量书写规范\n.a(A)  #.模组定义端口变量（实际变量）\n\n数据类型reg关键词reg主要用于定义特定类型的变量，即寄存器变量或称寄存器数据类型的变量。\n\n在物理结构上相对比较麻烦，左端有一个输入端口 D，右端有一个输出端口 Q， 并且 reg 型存储数据需要在CLK（时钟）沿的控制下完成，在 Verilog HDL 描述时也相对麻烦。\n\n在对reg 型变量进行赋值时，必须在 always 块内完成。\nreg a,b;    //声明2个reg型变量a和b(一位)reg[7:0]  out;  //out的宽度是8位\n\nwire\n在物理结构上只是一根线，在Verilog HDL描述时，对线型变量赋值用assign即可，相对比较简单。\n\nwire是最常用的net型数据变量，net型数据相当于硬件电路中的各种物理连接，其特点是输出的值随输入值的变化而变化。\n\nVerilog 模块中的输入/输出信号在没有明确指定数据类型时都被默认为wire型。\nwire a,b;//声明2个wire型变量a和b(一位)wire[7:0]  databus; //databus（数据总线）的宽度是8位wire[19:0] addrbus;//addrbus（地址总线）的宽度是20位\n\nVerilog 基本语法各种运算符算数运算符算术运算符，简单来说，就是数学运算里面的加减乘除，数字逻辑处理有时候也需要进行数字运算，所以需要算术运算符。\n\n\n\n符号\n使用方法\n说明\n\n\n\n+\na + b\na加上b\n\n\n-\na - b\na减去b\n\n\n*\na * b\na乘以b\n\n\n/\na / b\na除以b\n\n\n%\na % b\na模除b\n\n\n关系运算符关系运算符主要是用来做一些条件判断用的，在进行关系运算符时，如果声明的关系是假的，则返回值是0，如果声明的关系是真的，则返回值是1；所有的关系运算符有着相同的优先级别，关系运算符的优先级别低于算术运算符的优先级别\n\n\n\n符号\n使用方法\n说明\n\n\n\n&gt;\na &gt; b\na大于b\n\n\n&lt;\na &lt; b\na小于b\n\n\n&gt;=\na &gt;= b\na大于等于b\n\n\n&lt;=\na &lt;= b\na小于等于b\n\n\n==\na == b\na等于b\n\n\n!=\na != b\na不等于b\n\n\n赋值运算符\n\n\n符号\n使用方法\n说明\n\n\n\n=\na = b\n阻塞赋值，阻塞赋值是上一条语句已经执行赋值操作后才开始下一条语句的执行\n\n\n&lt;=\na &lt;= b\n非阻塞赋值，非阻塞赋值是可以在上一条语句赋值操作还没有完成前就开始下一条语句的执行\n\n\nassign\nassign a = b\n连续赋值，\n\n\n.\ncellAnd m0( .a(line0), .b(line1), .c(result) );\n“.”来映射赋值，编译器会根据上下文自己推断\n\n\n逻辑运算符逻辑运算符是连接多个关系表达式用的，可实现更加复杂的判断，一般不单独使用，都需要配合具体语句来实现完整的意思\n\n\n\n符号\n使用方法\n说明\n\n\n\n!\n!a\na的非，如果a为0，那么a的非是1。\n\n\n&amp;&amp;\na &amp;&amp; b\na 与上 b，如果a和b都为1，a&amp;&amp;b结果才为1，表示真\n\n\n||\na || b\na 或上 b，如果a或者b有一个为1，a||b结果为1，表示真。\n\n\n条件运算符条件操作符一般来构建从两个输入中选择一个作为输出的条件选择结构，功能等同于always中的if-else语句。\n\n\n\n符号\n使用方法\n说明\n\n\n\n? :\na ? b : c\n如果 a 为真，就选择 b，否则选择 c\n\n\n位运算符位运算符是一类最基本的运算符，可以认为它们直接对应数字逻辑中的与、或、非门等逻辑门。\n位运算符的与、或、非与逻辑运算符逻辑与、逻辑或、逻辑非使用时候容易混淆，逻辑运算符一般用在条件判断上，位运算符一般用在信号赋值上。\n\n\n\n符号\n使用方法\n说明\n\n\n\n~\n~a\n将 a 的每个位进行取反\n\n\n&amp;\na &amp; b\n将 a 的每个位与 b 相同的位进行相与\n\n\n|\na | b\n将 a 的每个位与 b 相同的位进行相或\n\n\n^\na ^ b\n将 a 的每个位与 b 相同的位进行异或\n\n\n移位运算符移位运算符包括左移位运算符和右移位运算符，这两种移位运算符都用0来填补移出的空位。\n\n\n\n符号\n使用方法\n说明\n\n\n\n&lt;&lt;\na &lt;&lt; b\n将 a 左移 b 位\n\n\n&gt;&gt;\na &gt;&gt; b\n将 a 右移 b 位\n\n\n拼接运算符Verilog中有一个特殊的运算符是C语言中没有的，就是位拼接运算符。用这个运算符可以把两个或多个信号的某些位拼接起来进行运算操作。\n\n\n\n符号\n使用方法\n说明\n\n\n\n{}\n{a, b}\n将 a 和 b 拼接起来，作为一个新信号\n\n\nVerilog语句assign语句assign是连续赋值命名的关键词，当等号右侧的驱动表达式中的任一信号变量发生变化时，此表达式被重新计算一遍，并将获得的数据立即赋值给左侧的目标变量。\nassign [延时] 目标变量名 = 驱动表达式;&#x27;timescale 10ns/100ps//仿真的基本时间单元是10ns，仿真时间精度是100psassign #6 R1 = A &amp; B;//延时6个时间单元（60ns）后再赋值\n\nparameter语句参数是一个特殊常量，parameter就是用来定义参数的关键字。\nparameter 标识符1 = 表达式或数值1, 标识符2 = 表达式或数值2, ... ;parameter A = 15, B = 4&#x27;b1011, C = 8&#x27;hAC;//parameter的参数传递功能module MULT4B #(parameter S = 4)(R, A, B);\n\nbegin-end语句引导顺序块语句\nbegin [:块名]\t语句1;\t语句2;\t...end\n\nif语句条件（if）语句用于控制执行语句要根据条件判断来确定是否执行。\n条件语句用关键字 if 和 else 来声明，条件表达式必须在圆括号中。\n条件语句使用结构说明如下：\nif (表达式1) 语句1;else if (表达式2) 语句2;else if (表达式2) 语句3;else 语句4;\n\ncase语句自上而下，按照顺序逐个对分支表达式进行判断，如果这一分支表达式等于控制表达式的值，就执行其对应操作；均不相等时，执行default操作；\ncase(表达式)\t取值1 : begin 语句1;语句2; end    取值2 : begin 语句3;语句4; end    default : begin 语句5; end\n\n\n分支表达式不能重复，否则会出现冲突；\n\n执行完某一操作后，跳出case语句；\n\n控制表达式与多个分支表达式匹配，只执行从上至下首个匹配项（判断顺序进行，执行一次后就跳出case语句了）；\ncasez进行控制表达式与分支表达式的比较时，不关注高阻态位（不管是控制表达式还是条件表达式，高阻态的位均默认为匹配）；casex进行控制表达式与分支表达式的比较时，不关注高阻态，以及不确定（不管是控制表达式还是条件表达式，高组态和不确定位均默认为匹配）；\n\n\ninitial语句initial 语句从 0 时刻开始执行，只执行一次。\nalways语句引导对模块逻辑功能描述的顺序语句，always语句块从仿真0时刻开始执行其中的行为语句；最后一条执行完成后，再开始执行其中的第一条语句，如此往复循环，直到整个仿真结束。\nalways @(posedge clock)begin  ......end\n\n循环语句while语句与C语言语法基本一致。\nwhile (表达式) begin    ...end\n\nfor语句与C语言语法基本一致。但需要注意变量的类型应该为interger，为int的全称。\ninteger i ;for(表达式1; 表达式2 ; 表达式3)  begin    ...end\n\nrepeat 循环，为verilog特有的。 repeat 循环语法格式如下：\nrepeat (循环次数) begin    ...end\n\nrepeat 的功能是执行固定次数的循环，它不能像 while 循环那样用一个逻辑表达式来确定循环是否继续执行。\nrepeat 循环的次数必须是一个常量、变量或信号。如果循环次数是变量信号，则循环次数是开始执行 repeat 循环时变量信号的值。即便执行期间，循环次数代表的变量信号值发生了变化，repeat 执行次数也不会改变。\nforever 循环forever 循环语法格式如下：\nforever begin    …end\n\nforever 语句表示永久循环，不包含任何条件表达式，一旦执行便无限的执行下去，系统函数 $finish 可退出 forever。forever 相当于 while(1) 。\n状态机Verilog 中状态机主要用于同步时序逻辑的设计，能够在有限个状态之间按一定要求和规律切换时序电路的状态。状态的切换方向不但取决于各个输入值，还取决于当前所在状态。 状态机可分为 2 类：Moore 状态机和 Mealy 状态机。\nMoore 型状态机Moore 型状态机的输出只与当前状态有关，与当前输入无关。\n输出会在一个完整的时钟周期内保持稳定，即使此时输入信号有变化，输出也不会变化。输入对输出的影响要到下一个时钟周期才能反映出来。这也是 Moore 型状态机的一个重要特点：输入与输出是隔离开来的。\nMealy 型状态机Mealy 型状态机的输出，不仅与当前状态有关，还取决于当前的输入信号。\nMealy 型状态机的输出是在输入信号变化以后立刻发生变化，且输入变化可能出现在任何状态的时钟周期内。因此，同种逻辑下，Mealy 型状态机输出对输入的响应会比 Moore 型状态机早一个时钟周期。\n状态机的一般结构\n状态机说明部分\n主控时序过程\n主控组合过程\n辅助过程\n\n//序列检查状态机module SCHK(input CLK, DIN ,RST,output SOUT);    parameter s0=41, s1=41, s2=42, s3=43, s4=44,    \t\t\ts5=45, s6=46, s7=47 ,s8=48;//状态机说明部分    reg [8:0] ST, NST;    always@(posedge CLK or posedge RST)//主控时序过程        if(RST)            ST &lt;= s0;    \telse            ST &lt;= NST;    always@(ST or DIN) begin//主控组合过程        case(ST)            s0 : if(DIN == 1&#x27;b1) NST &lt;= S1; else NST &lt;= s0;            s1 : if(DIN == 1&#x27;b1) NST &lt;= S2; else NST &lt;= s0;            s2 : if(DIN == 1&#x27;b0) NST &lt;= S3; else NST &lt;= s2;            s3 : if(DIN == 1&#x27;b1) NST &lt;= S4; else NST &lt;= s0;            s4 : if(DIN == 1&#x27;b0) NST &lt;= S5; else NST &lt;= s2;            s5 : if(DIN == 1&#x27;b0) NST &lt;= S6; else NST &lt;= s1;            s6 : if(DIN == 1&#x27;b1) NST &lt;= S7; else NST &lt;= s0;            s7 : if(DIN == 1&#x27;b1) NST &lt;= S8; else NST &lt;= s0;            s8 : if(DIN == 1&#x27;b0) NST &lt;= S3; else NST &lt;= s2;            default : NST &lt;= s0;        endcase    end    assign SOUT = (ST == s8);//辅助部分endmodule\n\n其他说明注释Verilog代码中的注释和c++语言相同，分为短注释(//)和长注释(/* … */)。短注释通常放在每行代码的后面或上面，用来注释这行代码的功能。\n四种逻辑状态verilog有4种逻辑状态0、1、z、x对应低、高电平、高阻态、不确定状态；出现x状态一般在simulation的时候。\n\nx是不定，就是不确定。一般在仿真的时候出现了，实际电路里是没有x的。\n\nVerilog的延迟：\n上升延迟：在门的输入发生变化的情况下，门的输出从0，x，z变化到1所需的时间成为上升延迟；\n下降延迟：下降延迟是指门的输出从1，x，z变化到0所需的时间；\n关断延迟：门的输出从0，1，x变化为高阻Z所需的时间。\n\n概念辨析组合逻辑与时序逻辑（1）组合逻辑：输出只是当前输入逻辑电平的函效（有延时），与电路的原始状念无关的逻辑电路。也就是说，当输入信号中的任何一个发生变化时，输出都有可能会根据其变化而变化，但与电路目前所处的状态没有任何关系（即逻辑电路没有记忆部件）。（2）时序逻辑：输出不只是当前输入的逻辑电平的函数，还与电路目前所处的状态有关的逻辑电路（即逻辑电路有记忆部件）。（1）组合逻辑：组合逻辑是由与、或、非门组成的网络。常用的组合电路有多路器、数据通路开关、加法器、乘法器等。（2）时序逻辑：时序逻辑是由多个触发器和多个组合逻辑块组成的网络。常用的有计数器、复杂的数据流动控制逻辑、运算控制逻辑、指令分析和操作控制逻辑。同步时序逻辑是设计复杂的数字逻辑系统的核心。时序逻辑借助于状态寄存器记住它目前所处的状态。在不同的状态下，即使所有的输入都相同，其输出也不一定相同。\n同步、异步异步指输入信号和时钟无关；同步指输入信号和时钟信号有关，实际上就是输入信号和时钟信号进行了与运算或者与非运算。实际开发中，经常有同步清零、异步清零、同步复位、异步复位等概念，下面就给与相关代码演示。\n//同步清零：module dff(d,clk,clr,q);input d,clk,clr;output q;reg q;always@(posedge clk)\tif(!clr) q&lt;=0;\telse q&lt;=d;endmodule\n\n//异步清零：module dff(d,clk,clr,q);input d,clk,clr;output q;reg q;always@(posedge clk or negedge clr)\tif(!clr) q&lt;=0;\telse q&lt;=d;endmodule\n\n事实上，清零(复位)、置数、使能三个信号可以任意选取同步、异步两种方式之一，所以这三个信号可以任意组成八种不同功能的电路，像异步复位、同步置数、异步使能等\n同步复位和异步复位的区别就在于 前者的复何信号不能出现在always语句的敏感信号表中，无论是同步复位还是异步复位，always语句的结构都是if(Reset)…else… ，否则，综合工具将不能正确的综合\n所有always语句中的赋值最好采用非阻塞赋值语 ，否则，可能会导致仿真与综合的不一致\n阻塞赋值与非阻塞赋值(1).非阻塞(Non_Blocking)赋值方式( 如 b &lt;= a; )\n\n块结束后才完成赋值操作。\nb的值并不是立刻就改变的。\n常用于编写综合模块。\n\n(2).阻塞(Blocking)赋值方式( 如 b = a; )\n\n赋值语句执行完后块才结束。\nb的值在赋值语句执行完后立刻就改变的。\n可能会产生意想不到的结果。\n\n实例加法器半加器module h_adder ( A, B, SO, CO) ;    input A,B;    output SO,CO;    assign SO = A ^ B;     assign CO = A &amp; B; endmodule\n\n全加器module f_adder(ain, bin, cin, cout, sum); \toutput cout, sum;    input ain, bin, cin;    wire net1, net2, net3;     h_adder Ul(ain, bin, net1, net2);     h_adder U2(.A(net1), .so(sum), .B(cin), .Co(net3));     or U3(cout, net2, net3); endmodule\n\n译码器module decoder(a,Q);\tinput [3:0]a;\toutput reg [7:0]Q;\talways@(a) begin\t\tcase(a)        4&#x27;h0: Q &lt;= 8&#x27;h3F;4&#x27;h1: Q &lt;= 8&#x27;h06;4&#x27;h2: Q &lt;= 8&#x27;h5B;4&#x27;h3: Q &lt;= 8&#x27;h4F;        4&#x27;h4: Q &lt;= 8&#x27;h66;4&#x27;h5: Q &lt;= 8&#x27;h6D;4&#x27;h6: Q &lt;= 8&#x27;h7D;4&#x27;h7: Q &lt;= 8&#x27;h07;        4&#x27;h8: Q &lt;= 8&#x27;h7F;4&#x27;h9: Q &lt;= 8&#x27;h6F;4&#x27;ha: Q &lt;= 8&#x27;h77;4&#x27;hb: Q &lt;= 8&#x27;h7C;        4&#x27;hc: Q &lt;= 8&#x27;h39;4&#x27;hd: Q &lt;= 8&#x27;h5E;4&#x27;he: Q &lt;= 8&#x27;h7B;4&#x27;hf: Q &lt;= 8&#x27;h71;\t\tendcase\tendendmodule\n\n计数器module cont6(clk,clr,en,set,q,co);\tinput clk,clr,en;\tinput set;\toutput reg[3:0] q;\toutput reg co;    always@(posedge en or posedge clk or negedge clr) begin        if(en)begin            if(clr == 0) begin\t\t\t\tq &lt;= 0;\t\t\t\tco &lt;= 0;\t\t\tend else begin                if(q &lt; 9) begin\t\t\t\t\tq &lt;= q + 1;\t\t\t\t\tco &lt;= 0;\t\t\t\tend else begin\t\t\t\t\tq &lt;= 0;\t\t\t\t\tco &lt;= 1;\t\t\t\tend\t\t\tend        end\tendendmodule \n\n分频器module div1hz(clk,q);\tinput clk;\toutput reg q;\treg [31:0]sys;    always@(posedge clk) begin\t\tif(sys &lt; 10000)\t\t\tsys = sys + 1;\t\telse begin\t\t\tq = !q;\t\t\tsys = 0;\t\tend\tend endmodule\n\n步进电机的控制module ST(EN,DIR,CLK,MOD,IN,D);\tinput CLK, EN, DIR, MOD;\tinput [3:0]IN;\toutput reg [3:0]D;    reg[2:0]CQ;    reg ck;    reg[31:0]sys;    always@(negedge ck)      begin        if(EN) begin            if(DIR)                CQ=CQ+1;            else                CQ=CQ-1;        end        if(MOD)begin            case(CQ[1:0])                0: D&lt;=4&#x27;b1000;                1: D&lt;=4&#x27;b0100;                2: D&lt;=4&#x27;b0010;                3: D&lt;=4&#x27;b0001;            endcase        end      else        case(CQ)            0:D&lt;=4&#x27;b1000;            1:D&lt;=4&#x27;b1100;            2:D&lt;=4&#x27;b0100;            3:D&lt;=4&#x27;b0110;            4:D&lt;=4&#x27;b0010;            5:D&lt;=4&#x27;b0011;            6:D&lt;=4&#x27;b0001;            7:D&lt;=4&#x27;b1001;        endcase    end    always@(negedge CLK)begin        if(sys&lt;100)            sys=sys+IN;        else begin            sys=0;            ck=!ck;        end    endendmodule\n\n序列检测状态机module SCHK(input CLK, DIN ,RST,output SOUT);    parameter s0=41, s1=41, s2=42, s3=43, s4=44,    \t\t\ts5=45, s6=46, s7=47 ,s8=48;    reg [8:0] ST, NST;    always@(posedge CLK or posedge RST)        if(RST)            ST &lt;= s0;    \telse            ST &lt;= NST;    always@(ST or DIN) begin        case(ST)            s0 : if(DIN == 1&#x27;b1) NST &lt;= S1; else NST &lt;= s0;            s1 : if(DIN == 1&#x27;b1) NST &lt;= S2; else NST &lt;= s0;            s2 : if(DIN == 1&#x27;b0) NST &lt;= S3; else NST &lt;= s2;            s3 : if(DIN == 1&#x27;b1) NST &lt;= S4; else NST &lt;= s0;            s4 : if(DIN == 1&#x27;b0) NST &lt;= S5; else NST &lt;= s2;            s5 : if(DIN == 1&#x27;b0) NST &lt;= S6; else NST &lt;= s1;            s6 : if(DIN == 1&#x27;b1) NST &lt;= S7; else NST &lt;= s0;            s7 : if(DIN == 1&#x27;b1) NST &lt;= S8; else NST &lt;= s0;            s8 : if(DIN == 1&#x27;b0) NST &lt;= S3; else NST &lt;= s2;            default : NST &lt;= s0;        endcase    end    assign SOUT = (ST == s8);endmodule\n参考资料老师上课的PPT和书本\n","categories":["笔记"],"tags":["学习笔记","EDA技术"]},{"title":"VS-Code配置指南","url":"/2021/05/18/VS-Code%E9%85%8D%E7%BD%AE/","content":"VS Code下载和安装官网下载点击VS Code进入VS Code官网下载最新版的VS Code，推荐下载64位。\n\n下载速度过慢解决办法首先，在前文给的官网地址总下载VS Code，然后复制下载地址。\n\n将下图总的红色部分的链接替换成vscode.cdn.azure.cn，然后开始下载即可。\n\n安装同意协议后，选择一个安装地址，附加任务可以选择都勾选。最后点击下一步，完成安装。\n\n主题推荐图标主题 Helium\n白色主题 Atom One Light Theme\n黑色主题 One Dark Pro\n\n以上只是推荐，其他主题，可以自行寻找安装。\n\n常用插件推荐Markdown Previewmd实时预览\nPolacode-2020代码截图\n常用编程字体推荐配置其他设置配置自动选择打开编码配置运行python代码配置运行C语言代码VS Code常用快捷键总结\n参考资料\n\n\n","categories":["技术"],"tags":["vscode","github","leetCode"]},{"title":"md文件的格式总结","url":"/2021/05/01/md%E6%96%87%E4%BB%B6%E7%9A%84%E6%A0%BC%E5%BC%8F%E6%80%BB%E7%BB%93/","content":"部分内容转载自ipandao完整md代码示例，仅用于学习记录，一定程度做备忘录用。# Heading 1## Heading 2### Heading 3#### Heading 4##### Heading 5###### Heading 6\n\nHeading 1Heading 2Heading 3Heading 4Heading 5Heading 6This is an H1&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;This is an H2-------------\n\nThis is an H1This is an H2常用效果字符和段落字符效果和横线等\n~~删除线~~ \t\t&lt;s&gt;删除线（开启识别HTML标签时）&lt;/s&gt;*斜体字*    \t\t_斜体字_**粗体** \t\t  __粗体__***粗斜体***\t\t___粗斜体___`这是指令`\n\n删除线                 删除线（开启识别HTML标签时）斜体字                  斜体字粗体                      粗体粗斜体                 粗斜体\n这是指令\n上标：X&lt;sub&gt;2&lt;/sub&gt;，下标：O&lt;sup&gt;2&lt;/sup&gt;\n\n上标：X2，下标：O2\n字体颜色&lt;font color&#x3D;&quot;ff0000&quot;&gt;这个是红色字体&lt;&#x2F;font&gt;，&lt;font color&#x3D;&quot; #00FF00&quot;&gt;这个是绿色字体&lt;&#x2F;font&gt;，&lt;font color&#x3D;&quot; 0000FF&quot;&gt;这个是蓝色字体&lt;&#x2F;font&gt;\n\n这个是红色字体，这个是绿色字体，这个是蓝色字体\n具体颜色参照：RGB颜色查询对照表\n文字排版&lt;div align=left&gt;文本左对齐&lt;/div&gt;&lt;div align=center&gt;文本居中&lt;/div&gt;&lt;div align=right&gt;文本右对齐&lt;/div&gt;&lt;div align=justify&gt;文本扩展&lt;/div&gt;\n\n文本左对齐\n文本居中\n文本右对齐\n文本扩展\n\n缩写缩写(同HTML的abbr标签)\n\n即更长的单词或短语的缩写形式，前提是开启识别HTML标签时，已默认开启\n\nThe &lt;abbr title=&quot;Hyper Text Markup Language&quot;&gt;HTML&lt;/abbr&gt; specification is maintained by the &lt;abbr title=&quot;World Wide Web Consortium&quot;&gt;W3C&lt;/abbr&gt;.\nThe HTML specification is maintained by the W3C.\n鼠标悬浮在对应文字上显示标签\n引用普通引用&gt; 引用文本 Blockquotes\n\n引用文本 Blockquotes\n\n多重应用&gt; 引用文本1&gt; 引用文本2&gt; &gt; 引用文本2.1&gt; &gt; 引用文本2.2&gt; &gt;&gt; &gt; &gt; 引用文本2.2.1&gt; &gt; &gt; 引用文本2.3&gt;&gt; 引用文本3\n\n\n引用文本1引用文本2\n\n引用文本2.1引用文本2.2\n\n引用文本2.2.1\n\n\n引用文本2.3\n引用文本3\n\n标签引用&#123;% blockquote [author[, source]] [link] [source_link_title] %&#125;content&#123;% endblockquote %&#125;&#123;% blockquote Seth Godin https:&#x2F;&#x2F;yao1208.github.io&#x2F; 欢迎来到我的blog %&#125;记录分享自己的学习过程 加油，曜！&#123;% endblockquote %&#125;\n\n记录分享自己的学习过程 加油，曜！Yao1208欢迎来到我的blog\n\n\n引用的行内混合 Blockquotes                  \n\n引用：如果想要插入空白换行即&lt;br /&gt;标签\n在插入处先键入两个以上的空格然后回车即可，\n\n锚点与链接[普通链接](http:&#x2F;&#x2F;localhost&#x2F;)[普通链接带标题](http:&#x2F;&#x2F;localhost&#x2F; &quot;普通链接带标题&quot;)&lt;https:&#x2F;&#x2F;github.com&gt;\t# 直接链接[跳转到本文锚点](#引用-Blockquotes)\t\t# 当前文章锚点跳转&#123;% post_link 如何搭建一个静态的个人BLOG %&#125;\t\t# 文章跳转链接&lt;a href&#x3D;&quot;&#123;% post_path &#39;gihub的常用命令总结&#39; %&#125;#hexo常用指令&quot;&gt;hexo 常用指令&lt;&#x2F;a&gt;\t# 不同文章跳转锚点链接：[邮箱联系我](mailto:yao1208@outlook.com)\n\n普通链接\n普通链接带标题\n直接链接：https://github.com\n当前文章锚点跳转：跳转到本文锚点\n文章跳转链接：如何搭建一个静态的个人BLOG\n不同文章跳转锚点链接：hexo 常用指令\n邮箱联系我\n代码高亮行内代码执行命令：npm install marked\nmd语法实现代码块function test() &#123;\tconsole.log(&quot;Hello world!&quot;);&#125; (function()&#123;    var box = function() &#123;        return box.fn.init();    &#125;;    box.prototype = box.fn = &#123;        init : function()&#123;            console.log(&#x27;box.init()&#x27;);\t\t\treturn this;        &#125;,        box.fn.init.prototype = box.fn;        window.box =box;&#125;)();var testBox = box();testBox.add(&quot;jQuery&quot;).remove(&quot;jQuery&quot;);\n\n使用标签语法实现代码块&#123;% codeblock lang:c %&#125;\tprintf(&quot;Hello World!&quot;);&#123;% endcodeblock %&#125;\n\nprintf(&quot;Hello World!&quot;);\n\n其他多种媒体图片图片加链接\n\n音乐 网易云\n\n视频 Bilibili这是我的年度报告\n由于Keep主题暂时没能适配视频不同端的大小，当前在PC端正常显示，手机端可能不能正常显示。\n \n\n在文章中插入 Pull quote。\n&#123;% pullquote [class] %&#125;content&#123;% endpullquote %&#125;\n\njsFiddle在文章中嵌入 jsFiddle。\n&#123;% jsfiddle shorttag [tabs] [skin] [width] [height] %&#125;\n\nGist在文章中嵌入 Gist。\n&#123;% gist gist_id [filename] %&#125;\n\niframe在文章中插入 iframe。用于实现音乐和视频\n&#123;% iframe url [width] [height] %&#125;\n\nImage在文章中插入指定大小的图片。参考图片部分\n&#123;% img [class names] &#x2F;path&#x2F;to&#x2F;image [width] [height] &#39;&quot;title text&quot; &quot;alt text&quot;&#39; %&#125;\n\nLink在文章中插入链接，并自动给外部链接添加 target=&quot;_blank&quot; 属性。\n&#123;% link text url [external] [title] %&#125;\n\nInclude Code插入 source/downloads/code 文件夹内的代码文件。source/downloads/code 不是固定的，取决于你在配置文件中 code_dir 的配置。\n&#123;% include_code [title] [lang:language] [from:line] [to:line] path&#x2F;to&#x2F;file %&#125;\n\n列表无序列表（减号）- 列表一- 列表二* 列表三* 列表四\n\n列表一\n列表二\n\n\n列表三\n列表四\n\n无序列表（加号和嵌套）+ 列表一+ 列表二    + 列表二-1        + 列表二-1-1    + 列表二-2+ 列表三    * 列表一    * 列表二    * 列表三\n\n列表一\n列表二\n列表二-1\n列表二-1-1\n\n\n列表二-2\n\n\n列表三\n列表一\n列表二\n列表三\n\n\n\n有序列表1. 第一行2. 第二行3. 第三行\n\n第一行\n第二行\n第三行\n\nGFM task list- [x] GFM task list 1- [x] GFM task list 2- [ ] GFM task list 3    - [ ] GFM task list 3-1    - [ ] GFM task list 3-2    - [ ] GFM task list 3-3- [ ] GFM task list 4    - [ ] GFM task list 4-1    - [ ] GFM task list 4-2\n\n GFM task list 1\n GFM task list 2\n GFM task list 3\n GFM task list 3-1\n GFM task list 3-2\n GFM task list 3-3\n\n\n GFM task list 4\n GFM task list 4-1\n GFM task list 4-2\n\n\n\n\n表格 Tables| 项目   |  价格 | 数量 || ------ | ----: | :--: || 计算机 | $1600 |  5   || 手机   |   $12 |  12  || 管线   |    $1 | 234  |\n\n默认左对齐\n ----:        右对齐\n  :--:        居中\n\n\n\n项目\n价格\n数量\n\n\n\n计算机\n$1600\n5\n\n\n手机\n$12\n12\n\n\n管线\n$1\n234\n\n\n\n特殊符号&amp;copy; &amp;  &amp;uml; &amp;trade; &amp;iexcl; &amp;pound;&amp; &lt; &gt; &amp;yen; &amp;euro; &amp;reg; &amp;plusmn; &amp;para; &amp;sect; &amp;brvbar; &amp;macr; &amp;laquo; &amp;middot; X&amp;sup2; Y&amp;sup3; &amp;frac34; &amp;frac14;  &amp;times;  &amp;divide;   &amp;raquo;18&amp;ordm;C  &quot;  &amp;apos;\n&copy; &amp;  &uml; &trade; &iexcl; &pound;&amp; &lt; &gt; &yen; &euro; &reg; &plusmn; &para; &sect; &brvbar; &macr; &laquo; &middot; \nX&sup2; Y&sup3; &frac34; &frac14;  &times;  &divide;   &raquo;\n18&ordm;C  &quot;  &apos;\n反斜杠 Escape 去除md转意\n*literal asterisks*\n\n科学公式 TeX(KaTeX)目前这部分存在问题，blog中暂时不能正常显示，目前作为一个小菜鸡，只能等待主题作者更新功能。\n行内的公式E&#x3D;mc^2\n$$行内的公式E=mc^2$$\nx &gt; y\n$$x &gt; y$$\n(\\sqrt&#123;3x-1&#125;+(1+x)^2)\n$$(\\sqrt{3x-1}+(1+x)^2)$$\n\\sin(\\alpha)^&#123;\\theta&#125;&#x3D;\\sum_&#123;i&#x3D;0&#125;^&#123;n&#125;(x^i + \\cos(f))\n$$\\sin(\\alpha)^{\\theta}=\\sum_{i=0}^{n}(x^i + \\cos(f))$$\n多行公式：\n\\displaystyle\\left( \\sum\\_&#123;k&#x3D;1&#125;^n a\\_k b\\_k \\right)^2\\leq\\left( \\sum\\_&#123;k&#x3D;1&#125;^n a\\_k^2 \\right)\\left( \\sum\\_&#123;k&#x3D;1&#125;^n b\\_k^2 \\right)\\\\\\displaystyle     \\frac&#123;1&#125;&#123;        \\Bigl(\\sqrt&#123;\\phi \\sqrt&#123;5&#125;&#125;-\\phi\\Bigr) e^&#123;        \\frac25 \\pi&#125;&#125; &#x3D; 1+\\frac&#123;e^&#123;-2\\pi&#125;&#125; &#123;1+\\frac&#123;e^&#123;-4\\pi&#125;&#125; &#123;        1+\\frac&#123;e^&#123;-6\\pi&#125;&#125;        &#123;1+\\frac&#123;e^&#123;-8\\pi&#125;&#125;         &#123;1+\\cdots&#125; &#125;        &#125;     &#125;\\\\f(x) &#x3D; \\int_&#123;-\\infty&#125;^\\infty\\hat f(\\xi)\\,e^&#123;2 \\pi i \\xi x&#125;\\,d\\xi\n$$\\displaystyle\\left( \\sum_{k=1}^n a_k b_k \\right)^2\\leq\\left( \\sum_{k=1}^n a_k^2 \\right)\\left( \\sum_{k=1}^n b_k^2 \\right)\\\\displaystyle    \\frac{1}{        \\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{        \\frac25 \\pi}} = 1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {        1+\\frac{e^{-6\\pi}}        {1+\\frac{e^{-8\\pi}}         {1+\\cdots} }        }    }\\f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi),e^{2 \\pi i \\xi x},d\\xi$$\n公式常用的网页：\n一份教程：https://www.cnblogs.com/linxd/p/4955530.html\n语法手册：https://en.wikibooks.org/wiki/LaTeX/Mathematics\n官网的 Live Demo：https://www.mathjax.org/#demo\n\n参考资料\nmd编辑器: Full example - Editor.md examples (ipandao.com): 2021-05-01 22:33:03\n\n","categories":["收集"],"tags":["Github","md格式"]},{"title":"常用命令总结","url":"/2021/05/01/gihub%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/","content":"Git常用命令git init \t\t# 新建一个空的仓库git status \t\t# 查看状态git add . \t\t# 添加文件git commit -m &#x27;注释&#x27; \t\t# 提交添加的文件并备注说明git remote add origin git@github.com:jinzhaogit/git.git \t# 连接远程仓库git push -u origin master \t\t\t# 将本地仓库文件推送到远程仓库git log \t\t# 查看变更日志git reset --hard \t\t\t\t\t# 版本号前六位 回归到指定版本git branch \t\t# 查看分支git branch newname \t\t\t\t\t# 创建一个叫newname的分支git checkout newname \t\t\t\t# 切换到叫newname的分支上git merge newname \t\t\t\t\t# 把newname分支合并到当前分支上git pull origin master \t\t\t\t# 将master分支上的内容拉到本地上\n\n附图片一张，仅用于学习记录\n\nhexo常用指令hexo s\t\t\t\t# 启动预览,默认4000端口hexo d -g \t\t\t# 生成并发布页面hexo clean\t\t\t# 清楚缓存文件hexo new &quot;title&quot;\t# 新建一篇文章hexo version\t\t# 显示版本hexo --safe\t\t\t# 安全模式，不会入插件和脚本\n\nLinux常用指令\n\nVim常用","categories":["收集"],"tags":["Github"]},{"title":"单片机学习笔记","url":"/2021/10/27/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"速查表常用汇编指令指令常用符号：\n\nRi和Rn: R表示当前工作寄存器区中的工作寄存器, i表示0或1, 即R0和R1。 n表示0～7, 即R0～R7, 当前工作寄存器的选定是由PSW的RS1和RS0位决定的。\n＃data: ＃表示立即数, data为8位常数。 ＃data是指包含在指令中的8位立即数。\n＃data16: 包含在指令中的16位立即数。\nrel: 相对地址, 以补码形式表示的地址偏移量, 范围为-128～+127。\naddr16: 16位目的地址。 目的地址可在全部程序存储器的64 KB空间范围内。\naddr11: 11位目的地址。 目的地址应与下条指令处于相同的2 KB程序存储器地址空间范围内。\ndirect: 表示直接寻址的地址, 即8位内部数据存储器RAM的单元地址（0～127), 或特殊功能寄存器SFR的地址。\nbit: 内部数据存储器RAM和特殊功能寄存器SFR中的可直接寻址位地址。\n@: 间接寻址寄存器或基地址寄存器的前缀, 如@Ri, @DPTR, 表示寄存器间接寻址。\n(X): 表示X中的内容。\n((X)): 表示由X寻址的单元中的内容, 即(X)作地址, 该地址的内容用((X))表示。\n\n\n数据传送指令MOV&#x2F;&#x2F;以累加器为目的操作数的指令MOV A，RnMOV A，directMOV A，@RiMOV A，#data&#x2F;&#x2F;以寄存器Rn为目的操作的指令MOV Rn,AMOV Rn,directMOV Rn,#data&#x2F;&#x2F;以直接地址为目的操作数的指令MOV direct,AMOV direct,RnMOV direct1,direct2MOV direct,@RiMOV direct,#data&#x2F;&#x2F;以间接地址为目的操作数的指令MOV @Ri,AMOV @Ri,directMOV @Ri,#data&#x2F;&#x2F;十六位数的传递指令MOV DPTR，#data16\n\nMOV是内部数据传送指令,就是在寄存器之间、寄存器与通用存储区之间的数据传送。\nMOVX&#x2F;&#x2F;累加器A与片外RAM之间的数据传递类指令MOVX A,@RiMOVX A,@DPTRMOVX @Ri,AMOVX @DPTR,A\n\nMOVX是外部数据存储器（外部RAM）与累加器A之间的数据传送指令。因为内部与外部的RAM地址有重叠现象，所以需要用不同的指令予以区分。\n使用时应当首先将要读或写的地址送入DPTR或Ri中，然后再用读写命令。其中，8位地址用Ri，16位地址用DPTR。\nMOVC&#x2F;&#x2F;程序存储器向累加器A传送指令MOVC A，@A+DPTRMOVC A, @A+PC&#x2F;&#x2F;查表MOV DPTR，TAB0MOV A，R0MOVC A，@A+DPTR TAB0: DB 3FH,06H,5BH,4FH,66H,6DH,7DH,07H,7FH,6FH\n\n MOVC是累加器与程序存储区之间的数据传送指令。又称为查表指令，是将ROM中的数送入A中，常用此指令来查一个已做好存储在在ROM中的表格（类似C语言中的指针）。它既可以用于内部程序存储区（内部ROM）也可以用于外部程序存储区（外部ROM）的数据传送。因为程序存储区内外统一编址的，所以一条指令就可以了。\nPUSH和POPPUSH directPOP direct\n\nPUSH称之为压栈，就是将direct中的内容送入堆栈中,POP称之为出栈，就是将堆栈中的内容送回到direct中。\nPUSH指令的执行过程是，首先将SP中的值加1，然后把SP中的值当作地址，将direct中的值送进以SP中的值为地址的RAM单元中。\nXCH和XCHDXCH A,RnXCH A, directXCH A, @RiXCHD A, @Ri\n\nXCH：字节交换指令，将两个操作数进行交换，只能在A与其他地址（直接地址Rn，@Ri）进行交换。\nXCHD：低半字节交换，将A与Ri的低半字节进行交换。\nSWAPSWAP A\n\nSWAP：将A中的值高、低4位交换。如：0FH（0000 1111）会被交换为F0H（1111 0000）。\n算数运算指令ADD与ADDCADD A,#DATAADD A,directADD A,RnADD A,@RiADDC A，RnADDC A,directADDC A,@RiADDC A,#data\n\n ADD：将A中的值与第二个操作数的值相加，最终结果存放在A中。\nADDC：将A中的值、第二个操作数的值、进位CY中的值相加，最终结果存放在A中。\n一般在多字节数相加时，低字节相加用ADD ，高字节相加就用ADDC。实现低字节产生的进位加到高字节相加当中，最终完成多字节数的相加。\nSUBBSUBB A，RnSUBB A,directSUBB A,@RiSUBB A,#data\n\nSUBB：带有带进位的减法。没有不带借位的减法指令，如果需要做不带位的减法指令（在做第一次相减时），只要将CY清零即可。\nINC与DECINC AINC RnINC directINC @RiINC DPTRDEC ADEC RnDEC directDEC @Ri\n\nINC：将后面操作数中的值加1。\nDEC：将后面操作数中的值减1。注意：DEC的可操作对象中没有DPTR\nMUL与DIVMUL ABDIV AB\n\nMUL：将A和B中的两个8位无符号数相乘，结果的高8位放在B中，低8位放在A中。\nDIV：将A中的8位无符号数除以B中的8位无符号数（A/B）。其商放在A中，余数放在B中。如果在做除法前B中的值是0，那么溢出标志位OV=1。\nDADA A\n\nDA：将二进制数相加的结果，调整为BCD码。不能调整减法结果。\n逻辑运算指令ANL与ORLANL A,RnANL A,directANL A,@RiANL A,#dataANL direct,AANL direct,#dataORL A,RnORL A,directORL A,@RiORL A,#dataORL direct,AORL direct,#dataXRL A,RnXRL A,directXRL A,@RiXRL A,#dataXRL direct,AXRL direct,#data\n\nANL:将第一个操作数与第二个操作数中的值按位与，结果送入第一个操作数中。\nORL:将第一个操作数与第二个操作数中的值按位或，结果送入第一个操作数中。\nXRL:将第一个操作数与第二个操作数中的值按位异或，结果送入第一个操作数中。\nCLR与CPLCLR ACPL A\n\nCLR：将A中的值清0。\nCPL：将A的值按位取反并放回A中。\nRL与RLC 与 RR与RRCRL ARLC ARR ARRC A\n\nRL：将A中的值（共八个位）逻辑左移\nRLC：将A中的值加上进位（共九个位CY和 A的八个位）逻辑左移\nRR ：将A中的值（共八个位）逻辑右移\nRRC：将A中的值加上进位（共九个位CY和 A的八个位）逻辑右移\n控制转移指令ACALL与LCALLACALL addr11LCALL addr16\n\nACALL最多跳2K距离，LCALL能跳64K。相对于AJMP和LJMP，他们多了保护断点的功能，转到子程序执行后，可以通过RET跳转回来。\nRET与RETIRET：从子程序返回，返回到LCALL或ACALL指令下一条指令处继续执行程序。\nRETI：从中断服务子程序返回，返回到中断时的断点处继续执行程序，断点未知。\nAJMP与LJMP与SJMP与JMPAJMP addr11LJMP addr16SJMP relJMP @A+DPTR\n\nAJMP最多跳2K距离，LJMP能跳64K，SJMP则最多只能跳256。\nJMP 则是将PC设置为A+DPTR，跳转到程序的对应位置。\nJZ与JNZJZ relJNZ rel\n\n这两个指令是判断寄存器A中的带有的Z寄存器是否为0，当A中的值为0时，Z = 1，JZ 跳转。当A中的值不为0时，Z = 0，JZ顺序执行。\nJZ：如果(A) = 0，则转移，否则顺序执行。\nJNZ：如果(A)! = 0，则转移，否则顺序执行。\nJC与JNCJC relJNC rel\n\n这两个指令是判断进位借位寄存器CY的指令，当\nJC：如果（CY = 1），则转移，否则顺序执行。\nJNC：Jump if Not Cy 如果没有进借位（CY = 0）就跳转，否则顺序执行。\nJB与JNBJB bit relJNB bit rel\n\n两个指令是判断一个二进制位是否为1的指令，如果为1则跳转，否则顺序执行。\nJB：如果bit = 1，则转移，否则顺序执行。\nJNB：如果bit = 0，则转移，否则顺序执行。\nJBCJBC bit rel\n\n相对于JB该指令会把操作的为赋值为0。\nJBC：如果 bit = 1，设置 bit = 0 然后转移，否则顺序执行。常用于计时器溢出标志TF0、TF1。\nCJNECJNE A,#data,relCJNE A,direct,relCJNE Rn,#data,relCJNE @Ri,#data,rel\n\nCJNE：Compare Jump Not Equal 将第一操作数中的值和第二操作数中的值进行比较，如果不相等，跳转到rel，否则就顺序执行。如果目的操作数大于源操作数则CY=1，若小于则CY=0；\nDJNZDJNZ Rn,relDJNZ direct,rel\n\nDJNZ：dec 1 jump if not zero 首先将操作数减一，将操作数中的值和源操作数中的值进行比较，如果不相等，跳转到rel，否则顺序执行。\nNOP空指令\n位操作指令MOVMOV C，bitMOV bit，C\n\n这组指令的功能是实现位累加器（CY）和其它位地址之间的数据传递。\nCLR与SETBCLR CCLR bitSETB CSETB bit \n\nCLR：操作 位 置‘0’\nSETB：操作 位 置‘1’\nCPL与ANL与ORLCPL CCPL bitANL C,bitANL C,&#x2F;bitORL C,bitORL C,&#x2F;bit\n\nCPL：对操作数取反，存回操作数。\nANL：求与，结果放在C中/bit是先对bit取反后参与运算。\nORL：求或，结果放在C中，/bit是先对bit取反后参与运算。\n伪指令ORGORG nn\n\n改变汇编器的地址计数器初值，提示此语句的程序后面放在以nn为起始地址连续存放在程序存储器。\nDB与DW与DSLN:DB 32,&#39;C&#39;,25H &#x2F;&#x2F;20H,43H,25HMN:DW 1234H,08H &#x2F;&#x2F;12H,34H,00H,08HL1:DS 32&#x2F;&#x2F;保留32个存储单元\n\nDB定义字节类型变量，一个字节数据占1个字节单元（8位），读完一个，偏移量加1DW定义字类型变量，一个字数据占2个字节单元（16位），读完一个，偏移量加2DS保留地址位置，保留32位\nEQU与BITEQU用于给数值定义别名。相当于C语言中的#define预处理指令。X1 EQU 2000H\nBIT用于给字符名称定义位地址。\nEND提示源程序段结束。\n51单片机常用特殊寄存器基础寄存器A（ACC） 累加器自身带有全零标志Z，若A = 0则Z = 1;若A ≠ 0则Z = 0。该标志常用作程序分枝转移的判断条件。\nB 乘除法寄存器寄存器，用于做乘、除法时放乘数或除数。\nPC程序计数器 (16位)PC的内容为将要执⾏的指令地址。 是唯⼀不可寻址的寄存器，不属于专⽤寄存器，⽤户不可对其进⾏读、写。 在执⾏转移、调⽤、返回的指令时能⾃动改变其内容，以改变程序的执⾏顺序。 复位时： PC=0000H ，程序从此单元开始执⾏，访问范围： 即0000H-FFFFH 即64K。\nPSW 程序状态字\n\n\nD7\nD6\nD5\nD4\nD3\nD2\nD1\nD0\n\n\n\nCY\nAC\nF0\nRS1\nRS0\nOV\n-\nP\n\n\n进、借位\n辅进、借位\n用户标志\n寄存器\n组选择\n溢出\n保留\n奇/偶\n\n\nCY：进位标志 有进、借位，CY= 1;无进、借位，CY= 0\nAC：辅助进、借位 (高半字节与低半字节间的进、借位)。\nF0：用户标志位 由用户定义其含义。\nRS1、RS0：工作寄存器组选择位\n通过修改PSW中的RS1、RS0两位的状态，就能任选一个工作寄存器区。\n\n\n\nRS1\nRS0\n使用的工作寄存器区R0~R7\n\n\n\n0\n0\n0区(00 ~ 07H)\n\n\n0\n1\n1区(08 ~ 0FH)\n\n\n1\n0\n2区(10 ~ 17H)\n\n\n1\n1\n3区(18 ~ 1FH)\n\n\n0V：溢出标志位 运算结果按补码运算理解。有溢出，OV = 1;无溢出，OV = 0。\nP：奇偶校验位 用来表示ALU运算结果中二进制数位“1”的个数的奇偶性。若为奇数，则P=1，否则为0。运算结果有奇数个1，P= 1;运算结果有偶数个1，P=0。\nSP 堆栈指针存放着当前堆栈地址。堆栈用于存储子程序调用、中断程序调用时程序返回的地址，或者用来临时保存某一寄存器的值。\nDPTR 16位寄存器分为DPL(低8位)和DPH(高8位)两个寄存器。用来存放16位地址值，以便用间接寻址或变址寻址的方式对片外数据RAM或程序存储器作64K字节范围内的数据操作。\nP0-P3 I/O端口寄存器四个并行输入/输出口(I/O)的寄存器。它里面的内容对应着管脚的输出。\n中断相关寄存器IP 中断优先级控制寄存器\n\n\nB7\nB6\nB5\nB4\nB3\nB2\nB1\nB0\n\n\n\n-\n-\nPT2\nPS\nPT1\nPX1\nPT0\nPX0\n\n\n保留\n保留\nT2高/低\n串行口高/低\nT1高/低\nINT1高/低\nT0高/低\nINT0高/低\n\n\n对应位置为1则优先级更高，如果是0则对应的优先级更低。\n如果IP寄存器对应位同为0或1，则由内部查询确定优先级。\nINT0 &lt; T0 &lt; INT1 &lt; T1 &lt; TI/RI &lt; T2\nTCON 定时/计数器控制寄存器\n\n\nB7\nB6\nB5\nB4\nB3\nB2\nB1\nB0\n\n\n\nTF1\nTR1\nTF0\nTR0\nIE1\nIT1\nIE0\nIT0\n\n\nT1请求有无\nT1工作启/停\nT0请求有无\nT0工作启/停\nINT1请求有/无\nINT1方式 下降沿/低电平\nINT0请求有/无\nINT0方式 下降沿/低电平\n\n\nIE 中断允许控制寄存器\n\n\nB7\nB6\nB5\nB4\nB3\nB2\nB1\nB0\n\n\n\nEA\n-\nET2\nES\nET1\nEX1\nET0\nEX0\n\n\n中断总控 允/禁\n保留\nT2 允/禁\n串行口 允/禁\nT1 允/禁\nINT1 允/禁\nT0 允/禁\nINT0 允/禁\n\n\nSCON 串行端口控制寄存器\n\n\nD7\nD6\nD5\nD4\nD3\nD2\nD1\nD0\n\n\n\nSM0\nSM1\nSM2\nREN\nTB8\nRB8\nTI\nRI\n\n\n方式\n选择\n多机控制\n串行接受允许/禁止\n欲发的第9位\n收到的第9位\n发送中断有/无\n接受中断有/无\n\n\n定时/计数器相关寄存器TMOD 定时/计数器方式控制寄存器\n\n\nB7\nB6\nB5\nB4\nB3\nB2\nB1\nB0\n\n\n\nGATE\nC/T\nM1\nM0\nGATE\nC/T\nM1\nM0\n\n\n门控开/关\n计数/定时\n方式\n选择\n门控开/关\n计数/定时\n方式\n选择\n\n\nGATE ：定时操作开关控制位，当GATE=1时，INT0或INT1引脚为高电平，同时TCON中的TR0或TR1控制位为1时，计时/计数器0或1才开始工作。\n若GATE=0，则只要将TR0或TR1控制位设为1，计时/计数器0或1就开始工作。\nC/T ：定时器或计数器功能的选择位。C/T=1为计数器，通过外部引脚T0或T1输入计数脉冲。C/T=0时为定时器，由内部系统时钟提供计时工作脉冲。\nM1 、M0：T0、T1工作模式选择位\n\n\n\nM1\nM0\n工作模式\n\n\n\n0\n0\n方式0，13位计数/计时器\n\n\n0\n1\n方式,1，16位计数/计时器\n\n\n1\n0\n方式2，8位自动加载计数/计时器\n\n\n1\n1\n方式3，仅适用于T0，T0分为两个独立的8位定时器/计数器TH0及TL0，T1在方式3时停止工作\n\n\nTCON 定时/计数器控制寄存器\n\n\nB7\nB6\nB5\nB4\nB3\nB2\nB1\nB0\n\n\n\nTF1\nTR1\nTF0\nTR0\nIE1\nIT1\nIE0\nIT0\n\n\nT1请求有无\nT1工作启/停\nT0请求有无\nT0工作启/停\nINT1请求有/无\nINT1方式 下降沿/低电平\nINT0请求有/无\nINT0方式 下降沿/低电平\n\n\nTF1：定时器T1溢出标志，可由程序查询和清零，TF1也是中断请求源，当CPU响应T1中断时由硬件清零。\nTF0：定时器T0溢出标志，可由程序查询和清零，TF0也是中断请求源，当CPU响应T0中断时由硬件清零。\nTR1：T1充许计数控制位，为1时充许T1计数。\nTR0：T0充许计数控制位，为1时充许T0计数。\nIE1：外部中断1请示源(INT1，P3.3)标志。IE1=1，外部中断1正在向CPU请求中断，当CPU响应该中断时由硬件清“0”IE1(边沿触发方式)。\nIT1：外部中断源1触发方式控制位。IT1=0，外部中断1程控为电平触发方式，当INT1(P3.3)输入低电平时，置位IE1。\nIE0：外部中断0请示源(INT0，P3.2)标志。IE0=1，外部中断1正在向CPU请求中断，当CPU响应该中断时由硬件清“0”IE0(边沿触发方式)。\nIT0：外部中断源0触发方式控制位。IT0=0，外部中断1程控为电平触发方式，当INT0(P3.2)输入低电平时，置位IE0。\nTH0,TL0 定时/计数器0 TH1,TH1 定时/计数器1串口相关寄存器SCON 串行端口控制寄存器\n\n\nD7\nD6\nD5\nD4\nD3\nD2\nD1\nD0\n\n\n\nSM0\nSM1\nSM2\nREN\nTB8\nRB8\nTI\nRI\n\n\n方式\n选择\n多机控制\n串行接受允许/禁止\n欲发的第9位\n收到的第9位\n发送中断有/无\n接受中断有/无\n\n\nSM0、SM1：串行口工作方式控制位。\n\n\n\nSM0和SM1\n方式\n工作方式\n\n\n\n00\n方式0\n波特率由振荡器频率所定：振荡器频率/12\n\n\n01\n方式1\n波特率由定时器T1或T2的溢出率和SMOD所定：2SMOD ×(T1溢出率)/32\n\n\n10\n方式2\n波特率由振荡器频率和SMOD所定：2SMOD ×振荡器频率/64\n\n\n11\n方式3\n波特率由定时器T1或T2的溢出率和SMOD所定：2SMOD ×(T1溢出率)/32\n\n\nSM2：多机通信控制位。\n多机通信是工作于 方式2 和 方式3 。\n\n在方式2，3时\n\n发送机，SM2 = 1 。\n接收机\nSM2 = 1\nRB8 = 1，激活RI，引起接收中断。\nRB8 = 0，不激活RI，不会引起接收中断。\n\n\nSM2 = 0，无论RB8为0为1，均激活RI引起接受中断。\n\n\n\n\n方式1时，当接收时，SM2 = 1，则只有收到有效停止位才激活RI\n\n方式0时，SM2必须为0。\n\n\nREN：允许接收位。\nREN用于控制数据接收的允许和禁止，REN=1时，允许接收，REN=0时，禁止接收。\nTB8：欲发送接收数据第9位\n 在方式2和方式3中，TB8是要发送的——即第9位数据位。在多机通信中同样亦要传输这一位，并且它代表传输的地址还是数据，TB8=0为数据，TB8=1时为地址。\nRB8：接收数据第9位\n在方式2和方式3中，RB8存放接收到的第9位数据，用以识别接收到的数据特征。\nTI：发送中断标志位。\n可寻址标志位。方式0时，发送完第8位数据后，由硬件置位，其它方式下，在发送或停止位之前由硬件置位，因此，TI=1表示帧发送结束，TI可由软件清“0”。\nRI：接收中断标志位。\n可寻址标志位。接收完第8位数据后，该位由硬件置位，在其他工作方式下，该位由硬件置位，RI=1表示帧接收完成。\nSUBF 串行数据缓冲器全称：serial data buffer，中文名为串行数据缓冲器。这个重叠的地址靠读/写指令区分：串行发送数据时，CPU向SBUF写入数据，此时99H表示发送SBUF；串行接收数据时，CPU从SBUF读出数据，此时99H表示接收SBUF。\nPCON 电源控制寄存器\n\n\nD7\nD6\nD5\nD4\nD3\nD2\nD1\nD0\n\n\n\nSMOD\n-\n-\n-\nGF1\nGF0\nPD\nIDL\n\n\n波特率加倍/不加倍\n×\n×\n×\n通用标志位\n通用标志位\n掉电方式位\n待机方式位\n\n\nSOMD：波特率是否加倍选择位，0波特率不加倍，1波特率加倍\nSMOD：该位与串口通信有关。SMOD=0; 串口方式1，2，3时，波特率正常。SMOD=1; 串口方式1，2，3时，波特率加倍。\nGF1,GF0:两个通用工作标志位，用户可以自由使用。\nPD:掉电模式设定位。PD=0 单片机处于正常工作状态。PD=1 单片机进入掉电（Power Down）模式，可由外部中断或硬件复位模式唤醒，进入掉电模式后，外部晶振停振，CPU、定时器、串行口全部停止工作，只有外部中断工作\nIDL:空闲模式设定位。IDL=0 单片机处于正常工作状态。IDL=1 单片机进入空闲（Idle）模式，除CPU不工作外，其余仍继续工作，在空闲模式下可由任一个中断或硬件复位唤醒。\nPCON地址位87H，不能位寻址，只能字节寻址，初始化时，SMOD = 0 。\n常用计算时序计算若 MCS − 51单⽚机外接晶振为  12MHz时，则单⽚机的四个周期的具体值为：\n振荡周期＝ 1/(12MHz)＝  1/12μs＝0.0833μs\n时钟周期＝振荡周期 *2＝ 1/6μs = 0.167μs\n机器周期＝时钟周期 * 6 =振荡周期 * 12 = 1μs\n指令周期＝ 1～4μs\n计时器初始化THx和TLx计算方式0（13位）：$$定时时间 = (8192-计数初值) * 晶振周期 * 12 = (8192-计数初值) * 机器周期$$在⽅式0下，计数⼯作⽅式时，计数值的范围是13位，即1～8192。\n最⼤定时时间为：(213 − 0) × 2μs = 16384μs = 16.384ms\n方式1（16位）：$$定时时间 = (65536-计数初值) * 晶振周期 * 12 = (65536-计数初值) * 机器周期$$在⽅式1下，计数⼯作⽅式时，计数值的范围是：1～65536。\n最⼤定时时间为：(216 − 0) × 2μs = 131072μs = 131.072ms\n方式2（8位）：$$定时时间 = (256-计数初值) * 晶振周期 * 12 = (256-计数初值) * 机器周期$$在⽅式2下，计数⼯作⽅式时，计数值的范围是8位，即1～256。\n最⼤定时时间为：(256 − 0) × 2μs = 512μs\n波特率计算⽅式0与⽅式2的波特率是固定的，为振荡频率fosc的12、32、64分频。\n⽅式1与⽅式3的波特率是可变的，由定时器T1的溢出率决定。\n⽅式0的波特率：$$波特率 = fosc / 12$$⽅式2的波特率：$$波特率 = 2SMOD fosc / 64$$⽅式1和⽅式3的波特率：$$波特率 = ( 2SMOD / 32 ) ( T1 × 溢出速率 )$$溢出周期 = 定时时间 = ( 256 - X ) × 晶振周期 12 = ( 256 - X ) ( 12 / fosc ) \n波特率 = ( 2SMOD / 32 ) ( T1溢出率 ) =( 2SMOD × / 32 ) { fosc / [12 ( 256 - X )]}$$计数初值为 X = 256 - [ fosc × ( 2SMOD )] / ( 384 × 波特率 )$$\n其他上电复位后寄存器的值\n\n\nSFR/引脚名称\n初始化状态\n\n\n\nPC\n0000H\n\n\nSP\n07H\n\n\nDPTR\n0000H\n\n\nPSW\n00H\n\n\nALE\n0\n\n\nPSEN\n1\n\n\nP0-P3\nFFH\n\n\n中断系统中断源\n\n\n中断符号\n名称\n引起中断原因\n中断服务程序入口地址\n中断源编号\n\n\n\nINT0\n外部中断0\nP3.2引脚低电平或下降沿信号\n0003H\n0\n\n\nINT1\n外部中断1\nP3.3引脚低电平或下降沿信号\n0013H\n2\n\n\nT0\n定时器中断0\n定时/计时器0计数回溢出信号\n000BH\n1\n\n\nT1\n定时器中断1\n定时/计时器1计数回溢出信号\n001BH\n3\n\n\nT2（52）\n定时器中断2\n定时器2中断\n002BH\n5\n\n\nTI/RI\n串行口中断\n串行通讯完成一帧数据发送或接受中断\n0023H\n4\n\n\n外部数据扩展单片机基础机器数的表示原码：原码是⼆进制数符号数值化以后的表示形式，是机器数的原始表示。 \n反码：正数的反码与原码相同。负数的反码由原码转换得到：符号位不变，数值位按位取反。 \n补码：正数的补码与原码相同。负数的补码是将反码最低位加⼀。\ntips：正数的原码、反码和补码都相同。 负数的补码的转换过程：原码 反码 补码 负数的补码再取补就得到原码。\n时序振荡周期：为单⽚机提供时钟信号的振荡源的周期，也称节拍，⽤P表示。 如果为内部时钟⽅式，振荡周期即为⽯英晶体的振荡周期\n时钟周期：是振荡源信号经⼆分频后形成的时钟脉冲信号，也称状态周期，⽤ 表示。 即⼀个时钟周期是振荡周期的2倍。\n机器周期：通常将完成⼀个基本操作所需的时间称为机器周期。  MCS − 51 中1个机器周期含6个时钟周期。\n指令周期：是指 CPU执⾏⼀条指令所需要的时间。⼀个指令周期通常含有1～4个机器周期。\n51单片机的引脚\n\n\n功能\n名称\n引脚\n引脚\n名称\n功能\n\n\n\n\nP1.0\n1\n40\nVCC\n\n\n\n\nP1.1\n2\n39\nP0.0/AD0\n\n\n\n\nP1.2\n3\n38\nP0.1/AD1\n\n\n\n\nP1.3\n4\n37\nP0.2/AD2\n\n\n\n\nP1.4\n5\n36\nP0.3/AD3\n\n\n\n\nP1.5\n6\n35\nP0.4/AD4\n\n\n\n\nP1.6\n7\n34\nP0.5/AD5\n\n\n\n\nP1.7\n8\n33\nP0.6/AD6\n\n\n\n复位信号\nRST/VPD\n9\n32\nP0.7/AD7\n\n\n\n串⾏⼝数据接收端\nRXD/P3.0\n10\n31\nEA/VPP\n访问程序存储器控制信号\n\n\n串⾏⼝数据发送端\nTXD/P3.1\n11\n30\nALE/PROG\n地址锁存控制信号，1/6分频\n\n\n外部中断请求0\nINT0/P3.2\n12\n29\nPSEN\n外部程序存储器读选通信号\n\n\n外部中断请求1\nINT1/P3.3\n13\n28\nP2.7/A15\n\n\n\n定时/计数器0\nT0/P3.4\n14\n27\nP2.6/A14\n\n\n\n定时/计数器1\nT1/P3.5\n15\n26\nP2.5/A13\n\n\n\n外部RAM写信号\nWR/P3.6\n16\n25\nP2.4/A12\n\n\n\n外部RAM读信号\nRD/P3.7\n17\n24\nP2.3/A11\n\n\n\n接外部晶振（CHMOD）\nXTAL2\n18\n23\nP2.2/A10\n\n\n\n接外部晶振（HMOS）\nXTAL1\n19\n22\nP2.1/A9\n\n\n\n\nVSS\n20\n21\nP2.0/A8\n\n\n\n⽚外三总线\nAB ：P0⼝经地址锁存后提供低8位地址， P2 ⼝直接提供⾼8位地址\nDB：P0⼝提供8位数据\nCB：EA, ALE, PESN, RD, WR等。\n接口技术串行口总线与系统扩展单片机总线信号系统扩展的方法扩展外部存储器常见存储器I/O口扩展AD/DA接口技术AD接口技术DA接口技术单片机外设控制数码管矩阵键盘LCD1602ESP-01S模块扩展E2PROM8255是具有一个8位控制器和三个8位数据口（a口B口C口），其中控制口用于写控制字，控制各数据口的工作方式和数据传送方向，数据口用于和单片机进行数据通讯，其中C口可作为两个独立的4位接口，各口地址由A1 A0决定8255有三种工作方式，方式0：基本方式，无需联络信号，写了控制字后直接对数据库输入或输出即可。方式1：选通方式需要联络信号进行查询，应答和产生中断，仅A口和B口具有此方式，此时C口高4位为a口的联络线，低四位为B口的联络线方式2：双向方式，仅a口有，此时A口既可作为输入接口，又可作为输出接口使用，此时输入和输出各使用一套联络线。\n起始条件S：当SCL高电平时，SDA由高电平向低电平转换；停止条件P：当SCL高电平时，SDA由低电平向高电平转换。\n主机发送启动信号后再发出寻址信号，7位器件地址1位R/W控制位，用0表示发送数据，1表示主机接收数据\n\n","categories":["笔记"],"tags":["学习笔记","单片机"]},{"title":"如何搭建一个静态的个人BLOG","url":"/2021/05/01/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%9D%99%E6%80%81%E7%9A%84%E4%B8%AA%E4%BA%BABLOG/","content":"前言不知道从那天起我就超级想搭建一个属于自己的博客。但是因为自己对这方面确实不是很懂。在搭建过程中，我遇到了好多的问题，有的问题再研究一段时间后，可以找到解决方案，但也有的问题，我到现在还没搞懂。不过我认为，在我搭建过程中，我确实学到了很多。故用这篇文章做下记录，但由于能力有限，不免会产生错误，希望大佬们多多包涵，并联系改正。\n 注意：本文只考虑 Windows 下的操作。使用 Linux 的大佬大概是不会来看我的博客的。ヾ(•ω•`)o\n第一步 安装必备软件并配置环境下载进入 Node.js官网 下载（推荐下载长期支持版）\n\n进入 Git官网 下载（在 windows 中直接点击右边电脑里面的下载就好了）\n\n另外，由于它们的服务器都在国外，所以速度方面可能不是很快。也可以去淘宝 Node.js 镜像和 Git的淘宝镜像 中下载。下载的时候要注意看清楚更新时间，找清楚最新版本。\n\n安装注意：以下代码块中的命令均可以在命令提示符、 PowerShell 或者 Git 中运行。\n安装 Node.js 和 GitNode.js 和 Git 程序的安装，没有什么可说的一路点 “下一步” 按默认配置就可以。\n安装 Hexo安装 hexo 也很简单，可以使用 npm 一键安装 Hexo 博客程序。\nnpm install -g hexo-cli\n\n使用淘宝镜像临时使用淘宝镜像的命令：\nnpm --registry https:&#x2F;&#x2F;registry.npm.taobao.org install express\n\n持久使用淘宝镜像的命令：\nnpm --registry https:&#x2F;&#x2F;registry.npm.taobao.org install express\n\n验证是否设置成功，出现以下内容，就代表你已经设置成功了！（＾∀＾●）ﾉｼ\nnpm info express\n\n\n如果你错误的设置了持久使用淘宝镜像，可是使用一下命令恢复默认\nnpm config set registry https:&#x2F;&#x2F;registry.npmjs.org\n\n第二步 注册并连接 GitHub注册 GitHub今天 GitHub官网 注册一个免费的账号。\n注意：Sign in 是登录，Sign up 是注册。\n填写好 Username（用户名）、Email address（电子邮箱地址）、和 Password（密码）后就可以完成注册了\n注意：用户名不可以和其他人重复。密码为至少15个字符或者至少包括一个数字和一个小写字母的8个字符。不算很复杂的要求呢！(/ω＼)\n然后完成邮箱验证，就可以愉快的使用 GitHub 了。\n总之和其他网站的注册并没有什么不同。\n连接 Github设置用户名和邮箱\n在应用列表中找到 Git ，然后运行 Git Bash。在 Git 中分别执行以下命令。其中GitHub 用户名和GitHub 邮箱要换成自己刚刚注册时使用的。\n注意：在命令中所有的符号都必须为英文半角。\ngit config --global user.name &quot;GitHub 用户名&quot;git config --global user.email &quot;GitHub 邮箱&quot;\n\n创建 SSH 密匙\n输入 ssh-keygen -t rsa -C &quot;GitHub 邮箱&quot;，然后它会提示要你输入passphrase 一般情况下没有必要设置，可以直接回车，直到恢复到等待输入命令的状态。\nssh-keygen -t rsa -C &#x27;GitHub 邮箱&#x27;\n\n在此电脑中进入 C:\\Users\\用户名\\.ssh 目录中，用记事本打开 id_rsa.pub 文件并复制里面的内容。\n登陆 GitHub ，进入 Settings 页面，选择左边栏的 SSH and GPG keys，点击 New SSH key。\nTitle 可以随便写，然后将 id_rsa.pub 内容粘贴到 Key 中，点击 Add SSH key 完成添加。\n\n验证连接在 Git Bash 输入 ssh -T git@github.com 输入 yes 回车确认后出现下图则代表连接成功。\n\n创建 Github Pages 仓库GitHub 主页右上角 New repository：\n\n\nRepository name 中输入 用户名.github.io`\n注意：这里的用户名只能是你注册的时候填写的那个用户名。\n\n\n\n\n然后点击 Create repository 创建。\n稳定访问GitHub\n对 GitHub 说”爱”太难了：访问慢、图片加载不出来。一个项目解决Github520\n\n使用Steam++也是一个不错的选择（虽然它好像已经改名为Watt Toolkit了）\n\n官网为：Watt Toolkit \n也可以选择再微软应用商店安装：Watt Toolkit - Microsoft Store 应用程序\n\n\n\n第三步 搭建并简单配置博客初始化Hexo选择一个合适的文件位置，然后右键，选择 Git Bash Here。在 Git Bash 中分别执行以下代码。\nhexo init &lt;folder&gt;  # 初始化&lt;folder&gt;是你保存博客的文件夹cd &lt;folder&gt;         # 进入你保存博客的文件夹npm install         # 安装对应组件\n\n这个地方可能会出现无法加载文件 ，因为在此系统上禁止运行脚本的提示。（忘记截图了(～￣▽￣)～）\n只需要以管理员身份打开PowerShell 输入以下代码然后选择Y即可。\nset-executionpolicy remotesigned\n\n等待建立完毕后，指定文件夹的目录如下：\n.├── _config.yml         # 网页的配置信息，需要一定的更改。├── package.json        # 应用程序信息，一般不需要更改├── scaffolds           # 存放博客模板的文件夹├── source              # 存放博客资源的文件夹，包括所有的博文和页面|   ├── _drafts|   └── _posts          # 一般新建的文档都放在这里└── themes              # 主题文件夹，默认只有一个主题，需要自己克隆\n\n本地预览在目录下打开 Git Bash 然后分别执行以下命令。\nhexo g   # 生成页面hexo s   # 启动预览\n\n打开浏览器输入在地址栏中输入 http://localhost:4000 即可进行本地预览。\n注意：如果出现页面加载不出来，可能是端口被占用了。在 Git Bash 中使用Ctrl+C 关闭服务器后执行 hexo s -p 80 更改端口后重试一下。\n如果每次启动都会被占用，你也可以找到node_modules\\hexo-server\\index.js文件，修改一下默认的port值。\n修改网页配置_config.yml网页基本设置\n\n\n参数\n描述\n\n\n\ntitle\n网站标题，最好用单引号引起来\n\n\nsubtitle\n网站副标题，最好用单引号引起来\n\n\ndescription\n网站描述，最好用单引号引起来\n\n\nkeywords\n网站的关键词。使用半角逗号 , 分隔多个关键词。\n\n\nauthor\n您的名字\n\n\nlanguage\n网站使用的语言。对于简体中文用户来说，使用不同的主题可能需要设置成不同的值，请参考你的主题的文档自行设置，常见的有 zh-Hans和 zh-CN。\n\n\ntimezone\n网站时区。中国一般可用 Asia/Shanghai。\n\n\n这个是我的设置你们可以参考一下\n\n其他详细参数由于其他数据一般不需要改动，而且介绍起来也挺复杂的，请到Hexo的官方文档 中查询后改动。\n设置部署到 GitHub在文件的最末尾更改为\ndeploy:  type: git  repository: git@github.com:你的用户名&#x2F;你的用户名.github.io.git  branch: master\n\n如果你对 GitHub 比较了解可以自行设置branch（分支），如果你也不太懂，那就默默用master就好。\n部署在目录下打开 Git Bash，分别执行以下命令安装 hexo-deployer-git：\nnpm install hexo-deployer-git --savehexo d\n\n主题安装进入 Hexo 的主题库中选择你喜欢的主题 Themes\n注意：点击主题的预览图片可以进入作者博客预览主题样式，点击主题名称可以转到 GitHub 中查看进行克隆\n选择一个喜欢的主题，比如简约且优雅的 Keep，点击他的主题名称可以转到其 GitHub 中 Keep的仓库 复制他的地址。\n在目录下的themes文件夹中打开 Git Bash，\ngit clone https:&#x2F;&#x2F;github.com&#x2F;XPoet&#x2F;hexo-theme-keep\n\n然后修改 _config.yml 中的 theme 为新主题名称 hexo-theme-keep 即可。\n注意：这个名称必须和 themes 文件夹中的名称一致。\n以上方法是通用的主题安装方法，当然你也可以参考你选择的主题对应的使用教程进行安装，方法大同小异，因此不再赘述。\n主题的配置配置主题是需要你参考对应主题的使用教程，对主题内部的_config.yml文件进行修改的过程。\n有的主题使用教程非常详细，相关功能也早已打包好。所以选择主题还是很重要的。\n主题的配置文件一般都在主题作者的博客中可以找到。\nKeep的使用教程\n新建博文在目录下打开 Git Bash，执行以下命令创建博文：\nhexo new &quot;你的博文的标题&quot;\n\n然后在source_posts 文件夹中会出现一个”你的博文的标题“的文件这个文件是根据你在scaffolds 文件夹下的post.md创建的，如果有需求可以去更改。\n打开这个你新建好的博文文件，使用md语法书写你的博文就好了。\n写完后可以运行下面代码将文章部署到 GitHub 上。\nhexo g   \t\t\t# 生成页面hexo d  \t\t \t# 部署发布\n\n常用指令hexo s\t\t\t\t# 启动预览hexo d -g \t\t\t# 生成并发布页面hexo clean\t\t\t# 清楚缓存文件hexo new &quot;title&quot;\t# 新建一篇文章\n\n其他更详细指令，请参考hexo的文档指令页面\n第四步 如何高效的使用博客使用编辑器编辑你的博文 Typora是一款轻便简洁的Markdown编辑器，支持即时渲染技术，这也是与其他Markdown编辑器最显著的区别。即时渲染使得你写Markdown就想是写Word文档一样流畅自如，不像其他编辑器的有编辑栏和显示栏。\nVS code 是众所周知的神器，它虽然已经默认集成 Markdown 文档编辑插件，支持高亮 Markdown 的语法，但想要实时预览还需要进行一定的配置，有一点的上手难度。\n详细请参考知乎TRHX的主流Markdown编辑器推荐\n使用pic go配合阿里云OSS存储图片md文件中无法插入图片，如果你想要自己的文章图文并茂，那么就需要使用图床。这里推荐的是阿里云的OSS存储，一年只要9元钱。( ⓛ ω ⓛ *)\n如果你选择的是Typora编辑你的文章，那么Pic go就很适合管理你的图片了，毕竟内置的还是方便。\n下载并安装PicGoPicGo下载速度感人，可以使用油猴插件–Github 增强 - 高速下载，敲好用！！Windows平台下载这个exe就好了，图示多个下载源为油猴插件效果。\n\n购买阿里云的对象存储服务注册登陆阿里云（推荐用支付宝登陆），找到对象存储服务并购买。OSS管理控制台 (aliyun.com)\n创建BucketBucket可以理解一个存储空间，注意这里读写权限要设置成公共读，外网才可以通过链接访问图片。其它默认即可。\n注意：记下你的Bucket名字。\n注意：记得打开公共读权力。\n创建一个用户访问点击自己头像，然后选择访问控制，点击用户，选择新建用户，之后进行用户配置，注意要勾选编程访问，控制台密码登录可以不选择，登录名称，显示名称自己设定。确定后得到创建用户。\n注意：这里要记下AccessKey ID 和 AccessKeySecret\n设置typora参照下图进行设置，路径选择你安装PicGo时使用的路径。其实这里也可以使用typora内置的PicGo，但就个人体验不是很良好，所以建议使用app。\n设置PicGo将之前记下的东西依次填写进去即可。\n\n注意：存储空间名为之前申请的Bucket\n注意：存储区域的代码，请查询阿里云的文档访问域名和数据中心 - 对象存储 OSS - 阿里云 (aliyun.com)。\n其他教程由于撰写这部分的时候还没有配置好图床，所以没有详细的图片教程，如果文字不能表现清楚，可以参考下面的文章。（目前基本已经补充）\n阿里云OSS PicGo 配置图床教程 超详细 - 知乎 (zhihu.com)\n备份md文件推荐 坚果云，每月免费的流量一般就够用了。\n当然也可以选择使用github，但可能还是存在一定的上手难度。\n此文章经过反反复复多次修改，不免有些错漏，希望朋友们可以友好指出，留言或邮箱联系，很乐意成为你的朋友。[](￣▽￣)*\n参考资料\nMOxFIVE Blog: http://moxfive.xyz/ate  2020-04-18 16:35:03\nKeep使用教程：https://keep-docs.xpoet.cn/  2021-05-04 17:47:00\nHexo官方文档：https://hexo.io/zh-cn/docs/ate  2020-04-18 16:35:03\n主流Markdown编辑器推荐：https://zhuanlan.zhihu.com/p/69210764  2021-05-04 17:47:00\n阿里云：https://help.aliyun.com/document_detail  2021-05-04 18:09:57\n\n","categories":["技术"],"tags":["Github","Blog"]},{"title":"日常休整电脑","url":"/2021/09/14/%E6%97%A5%E5%B8%B8%E4%BC%91%E6%95%B4%E7%94%B5%E8%84%91/","content":"iso文件的获取从第三方网站获取老版的MSDN 已经不更新了，失落。＞︿＜新版的MSDN 需要注册账号，但是还挺好用的。\n以上下载方式，可能需要用到迅雷，且至少我没有完美的替换方案。如果不想使用迅雷，可以使用下面的方式。\n从微软官方获取（疑似失效）Win10：下载 Windows 10 \n进入页面后按F12打开开发者选项，点击右上角的切换设备仿真或按快捷键Ctrl+Shift+M，切换到手机模式，然后刷新界面后按提示下载windows镜像。\n\nWin11：下载 Windows 11 Win11的镜像居然可以直接下载，或许这也是一种推广手段呢！😂\n制作启动盘没有试过太多的PE工具箱，所以咱就无脑推微PE工具箱了。盛名之下无虚士嘛！\n如果你爱好开源软件，也可以选择这个Rufus，没用过不做评价。\n安装系统的标准流程参考大佬的教程如何用PE安装windows 10系统\n附一张进入Bios的启动按键图\n\n安装完成后的调试\n移动库至其他盘\n\n安装驱动\n\n系统和Office激活\n\nDirectX修复\n\n常用软件库\n\n\n最近有点忙，以后会回来填坑的，目前只有个名字o~o(￣▽￣)o\n常用软件浏览器类软件edge/chrome解压缩类软件bandiZip视频播放软件potplayer文本编辑器VS code下载类软件FDM工具Office Tool Plus截图软件Snipaste桌面整理软件CoolDesk系统优化软件DISM++Everything插件PPT插件iSlideOffice tab centerInfinity新建标签页TampermonkeyGreasy fork\nUWP软件推荐MS TODONotepadsSteam++LyricEase网站BilibiliGitHubAcFunHelloGitHub学习强国我爱分享网中国知网数字生活指南数字生活指南 | 让工作学习生活更高效！guidebook.top\n","categories":["技术"],"tags":["软件"]},{"title":"破解澳大利亚信号局纪念币的思路和过程","url":"/2022/09/20/%E7%A0%B4%E8%A7%A3%E6%BE%B3%E5%A4%A7%E5%88%A9%E4%BA%9A%E4%BF%A1%E5%8F%B7%E5%B1%80%E7%BA%AA%E5%BF%B5%E5%B8%81%E7%9A%84%E6%80%9D%E8%B7%AF%E5%92%8C%E8%BF%87%E7%A8%8B/","content":"2022年9月1日，澳大利亚信号局公布了他们的75周年纪念币，这是一枚标准的澳大利亚50美分硬币，其中嵌入了各种加密谜题。作为学校推理协会的成员，我表示希望去破解一下，但是确实是能力有限，没能在第一时间破解出结果。时至今日，在参考了众多成功通关的朋友们的文章后，我终于下笔，试图描述一个完整游戏的流程。\n\n声明：个人并没有真正破解出一下题目，所以题目思路均为网络收集。官方将在9月底公布答案，感兴趣的同学请自行关注。希望自己破解的同学可以可以看下面更清晰的背面图进行破解。\n第一关 盲文首先，拿到一个复杂的题目，应该从最简单的地方开始看起。如果是一个平时善于观察的人，就可以很轻易的认出正面的凸起就是常常在电梯上见到的盲文。\n\n\n\na/1\nb/2\nc/3\nd/4\ne/5\nf/6\ng/7\nh/8\ni/9\nj/0\n\n\n\n⠁\n⠃\n⠉\n⠙\n⠑\n⠋\n⠛\n⠓\n⠊\n⠚\n\n\n硬币中的图案翻译如下：\n\n\n\nB\nT\nH\nA\nS\nA\n\n\n\n⠉\n⠃\n⠋\n⠁\n⠑\n⠙\n\n\n3\n2\n6\n1\n5\n4\n\n\n将盲文数字顺序重新排列上分的字母可得：ATBASH\n第二关 Atbash加密通过第一关，我们得到了Atbash的提示，这是一种常见的加密方法。阿特巴希密码将字母表（希伯来语）整个扭转：第一个字母（aleph）与最后一个（taw）相替换，第二个（beth）与倒数第二个（shin）相替换，如此类推。映射到26个英文字母中，便可以得到上下对应的兑换表。\n前13个字母： A|B|C|D|E|F|G|H|I|J|K|L|M后13个字母： Z|Y|X|W|V|U|T|S|R|Q|P|O|N\n\n目前还有内外两环的字母，以及看上去很像16进制一大串字母。\n外环数据有两组：\n\ndvzivzfwzxrlfhrmxlmxvkgzmwnvgrxfolfhrmvcvxfgrlm\nurmwxozirgbrm7drwgsc5wvkgs\n\n进行Atbash解密得到：\n\nweareaudaciousinconceptandmeticulousinexecution\nfindclarityin7widthx5depth\n\n进行简单的断句翻译后可以得到：\n\nwear e audacious in concept and meticulous in execution（理念大胆，执行一丝不苟）\nfind clarity in 7 width 5 depth（在 7 宽 5 深中找到清晰度）\n\n尝试用Atbash对内环进行解密，发现不可读\n第三关 所谓清晰度通过第二关后，我们得到了一句提示，在7*5中找到清晰度。恰好，内环似乎正好是70个字符，两个7 x 5。\nbgoamvoeiatsirlngttneogrergxnteaifcecaieoalekfnr5lwefchdeeaeee7nmdrxx5\n\n通过观察，我们会发现竖着似乎存在部分词语（例如belong  tea等），似乎可以阅读。完整写出为：\nbelongingtoagreatteamstrivingforexcellencewemakeadifferencexorhexa5d75\n可以清楚的得出一句话：\nBelonging to a great team striving for excellence we make a difference XOR HEX A5D75.（属于一个追求卓越的伟大团队，我们有所作为 xor hex a5d75）\n第四关 XOR加密通过前三关的经验，显然最后的XOR HEX A5D75是一个提示。这将会是一个艰苦的过程，尽管我们有Python。\n第一个数（硬币正面右下角）：E3B8287D4290F7233814D7A47A291DC0F71B2806D1A53B311CC4B97A0E1CC2B93B31068593332F10C6A3352F14D1B27A3514D6F7382F1AD0B0322955D1B83D3801CDB2287D05C0B82A311085A033291D85A3323855D6BC333119D6FB7A3C11C4A72E3C17CCBB33290C85B6343955CCBA3B3A1CCBB62E341ACBF72E3255CAA73F2F14D1B27A341B85A3323855D6BB333055C4A53F3C55C7B22E2A10C0B97A291DC0F73E3413C3BE392819D1F73B331185A3323855CCBA2A3206D6BE3831108B第二个数字（第三关给的提示A5D75重复）：A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5D75A5将第一个数字和第二个数字异或后得到：466f7220373520796561727320746865204175737472616c69616e205369676e616c73204469726563746f72617465206861732062726f7567687420746f6765746865722070656f706c6520776974682074686520736b696c6c732c2061646170746162696c69747920616e6420696d6167696e6174696f6e20746f206f70657261746520696e2074686520736c696d2061726561206265747765656e2074686520646966666963756c7420616e642074686520696d706f737369626c652E\n\n网上随便找个hex转字符串的工具可以得到：\nFor 75 years the Australian Signals Directorate has brought together people with the skills, adaptability and imagination to operate in the slim area between the difficult and the impossible.（75 年来，澳大利亚信号局将具有技能、适应能力和想象力的人们聚集在一起，在困难和不可能之间的狭小区域开展工作。）\n第五关 致敬经典外圈共有三种不同的状态，考虑是摩尔斯码，通过试错，分析可得深色为.，白色为结果-,条状线为/，翻译过来是“1947 DSB Albert Park”。\ndvzivzfwzxrlfhrmxlmxvkgzmwnvgrxfolfhrmvcvxfgrlmurmwxozirgbrm7drwgsc5wvkgs.----&#x2F;----.&#x2F;....-&#x2F;--...&#x2F;-..&#x2F;...&#x2F;-...&#x2F;.-&#x2F;.-..&#x2F;-...&#x2F;.&#x2F;.-.&#x2F;-&#x2F;.--.&#x2F;.-&#x2F;.-.&#x2F;-.-\n\n内环有两种状态猜测是二进制，猜测白色的是0，黑色的是1，可以解读为“**ASDCbr2022**”。具体思路比较特殊，一般人看到二进制可能不会将其七个为一个单位进行分割。一个比较合理的思路是，可以通过后面比较明显的相似性进行解读，推理出后面2022中的三个2后，再推出0，并想到把整个二进制切分为七个一组。再通过ASCII码解出整个密码。\nbgoamvo eiatsir lngttne ogrergx nteaifc ecaieoa lekfnr5 lwefchd eeaeee7 nmdrxx51000001 1010011 1000100 1000011 1100010 1110010 0110010 0110000 0110010 0110010   A       S\t   D\t   C\t   b\t   r\t   2\t   0\t   2\t   2\n\n据说，解出这个密码就可以去澳大利亚信号局工作了哦。\n参考资料\nA:\\OBSOLE~1\\NERD\\Solving the Australian Signals Directorate cryptography challenge coin (obsoletenerd.com)\n\n","categories":["收集"],"tags":["破解","推理"]},{"title":"算法学习笔记","url":"/2022/03/17/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"算法基础程序性能分析在程序设计中算法的性能分析是非常重要的，针对一个具体的问题可能提出若干种不同的算法实现。比较这些算法种找出性能优劣，就显得格外重要。一般情况下，主要从两个方面评估算法：\n 1、算法的执行所需要的时间（时间复杂度）\n 2、算法所占用的存储空间（空间复杂度）\n时间复杂度时间复杂度：受限于不同计算机复杂的外在条件，程序的运行时间受影响幅度较大。因此，在实际场景中，我们更喜欢用一个估值来表示算法所编程序的运行时间。\n常见的时间复杂度量级排序：\n$O(1)$常数阶 &lt; $O(\\log n)$对数阶 &lt; $O(n)$线性阶 &lt; $O(n^2)$平方阶 &lt; $O(n^3)$立方阶 &lt; $O(2^n)$指数阶\n\n时间复杂度的分析包含平均时间复杂度、均摊时间复杂度、最坏时间复杂度、最好时间复杂度诸多情况，我们主要关心的还是一般情况下的数据形式。所以，一般说到算法的时间复杂度是多少指的都是一般情况。\n\n空间复杂度空间复杂度：算法所编写的程序实际包含程序代码本身、输入输出数据以及运算过程中申请的存储空间三个部分，但由于，对算法的空间复杂度影响最大的，往往是程序运行过程中所申请的临时存储空间。一般仅考虑程序运行过程中所申请的临时存储空间。\n\n在多数场景中，一个好的算法往往更注重时间复杂度的比较，而空间复杂度只要求在一个合理的范围内。\n\n内存管理机制不同的编程语言都各自的内存管理方式。\nC++的内存管理C++的程序运行时所需的内存空间可以基本分为代码区（存放可执行程序的机器码）、静态数据区（存放已初始化的全局和静态变量， 常量数据（如字符串常量））、堆区（程序中动态分配的内存）、栈区（编译器自动管理分配）。\n内存对齐为什么要进行内存对齐：内存对齐使数据读取更高效\n数据读取的处理器只能从地址为k的倍数的内存处开始读取数据。这种读取方式相当于将内存分为了多个”块“，假设内存可以从任意位置开始存放的话，数据很可能会被分散到多个“块”中，处理分散在多个块中的数据需要移除首尾不需要的字节，再进行合并，非常耗时。\n为了提高数据读取的效率，程序分配的内存并不是连续存储的，而是按首地址为k的倍数的方式存储；这样就可以一次性读取数据，而不需要额外的操作。\n内存对齐的规则\n定义有效对齐值（alignment）为结构体中 最宽成员 和 编译器/用户指定对齐值 中较小的那个。\n(1) 结构体起始地址为有效对齐值的整数倍\n(2) 结构体总大小为有效对齐值的整数倍\n(3) 结构体第一个成员偏移值为0，之后成员的偏移值为 min(有效对齐值, 自身大小) 的整数倍\n相当于每个成员要进行对齐，并且整个结构体也需要进行对齐。\n\n编译器一般都会做内存对齐的优化操作，也就是说当考虑程序真正占用的内存大小的时候，也需要认识到内存对齐的影响。\n\nC#的内存管理首先，C#是一种托管语言，它的垃圾回收机制（GC）是由.net平台负责的。所以，在使用过程中极少会考虑到内存使用状况以及项目在运行过程中是如何进行内存管理的。\n\n栈区：由编译器自动分配释放 ，存放值类型的对象本身，引用类型的引用地址（指针），静态区对象的引用地址（指针），常量区对象的引用地址（指针）等。\n\n堆区（托管堆）:用于存放引用类型对象本身。在c#中由.net平台的垃圾回收机制（GC）管理。栈，堆都属于动态存储区，可以实现动态分配。\n\n静态区及常量区：用于存放静态类，静态成员（静态变量，静态方法），常量的对象本身。由于存在栈内的引用地址都在程序运行开始最先入栈，因此静态区和常量区内的对象的生命周期会持续到程序运行结束时，届时静态区内和常量区内对象才会被释放和回收（编译器自动释放）。所以应限制使用静态类，静态成员（静态变量，静态方法），常量，否则程序负荷高。\n\n代码区：存放函数体内的二进制代码。\n\n\n数组数组是存放在连续内存空间上的相同类型数据的集合，数组的内存空间一般是连续的，所以我们在使用数组增加或删除一个元素的时候，就要对后面的元素进行位移。\n二分查找法二分查找法的前提是数组为有序数组，且数组中无重复元素。重点是对边界条件的控制，一般分为，**[左闭右闭]，或者[左闭右开)**。\n704. 二分查找//[左闭右闭]public class Solution &#123;    public int Search(int[] nums, int target) &#123;        int left = 0, middle, right = nums.Length-1;        while(left &lt;= right)        &#123;            //middle = (left + right) / 2;            middle = left + ((right-left) &gt;&gt; 1);            if(nums[middle] &gt; target)                right = middle - 1;            else if(nums[middle] &lt; target)                left = middle + 1;            else                return middle;        &#125;        return -1;    &#125;&#125;//[左闭右开)public class Solution &#123;    public int Search(int[] nums, int target) &#123;        int left = 0, middle, right = nums.Length;        while(left &lt; right)        &#123;            //middle = (left + right) / 2;            middle = left + ((right-left) &gt;&gt; 1);            if(nums[middle] &gt; target)                right = middle;            else if(nums[middle] &lt; target)                left = middle + 1;            else                return middle;        &#125;        return -1;    &#125;&#125;\n\n\n相对于[左闭右开)，[左闭右闭]的代码在形式上更加规整，逻辑也更加顺畅，一般情况应考虑写[左闭右闭]的代码。\n\n双指针法双指针法是使用快慢两个指针（或下标）使用一个for循环，完成两个for循环嵌套效果的方法，相对于暴力解法，大大提高了代码的运行效率。\n27. 移除元素public class Solution &#123;    public int RemoveElement(int[] nums, int val) &#123;        int slow = 0;        for(int fast = 0; fast &lt; nums.Length; fast++)//快指针遍历完成就可以结束        &#123;            if(nums[fast] != val)                nums[slow++] = nums[fast];        &#125;        return slow;    &#125;&#125;\n\n滑动窗口法滑动窗口法是一种特殊的双指针法，不过更加注重的两个指针中间的区间范围。注意在合理的位置对窗口长度进行计算，凡是符合条件的且窗口大小发生变化的位置都要计算。\n209. 长度最小的子数组public class Solution &#123;    public int MinSubArrayLen(int target, int[] nums) &#123;        int i = 0,sum = 0, result = Int32.MaxValue;        for(int j = 0; j &lt; nums.Length; j++)        &#123;            sum += nums[j];            while(sum &gt;= target)            &#123;                result = result &lt; (j - i + 1) ? result : (j - i + 1);                sum -= nums[i++];            &#125;             &#125;        return result == Int32.MaxValue ? 0 : result;    &#125;&#125;\n\n数组难题59. 螺旋矩阵 II输入：n &#x3D; 3输出：[[1,2,3],[8,9,4],[7,6,5]]\n\npublic class Solution &#123;    public int[][] GenerateMatrix(int n) &#123;        int startx = 0, starty = 0, i, j;        int loop = n / 2;        int count = 1, offset = 1;        int[][] arr = new int[n][];        for (int index = 0; index &lt; arr.Length; index++)        &#123;            arr[index] = new int[n];        &#125;        while(loop-- != 0)        &#123;            i = startx;            j = starty;            for(j = starty; j &lt; starty + n - offset; j++)                arr[startx][j] = count++;            for(i = starty; i &lt; startx + n - offset; i++)                arr[i][j] = count++;            for(; j &gt; starty; j--)                arr[i][j] = count++;            for(; i &gt; startx; i--)                arr[i][j] = count++;            startx++;            starty++;            offset += 2;        &#125;        if(n % 2 != 0)            arr[n/2][n/2] = count;        return arr;    &#125;&#125;\n\n链表栈与队列字符串树图哈希表查找算法排序算法算法设计思想递归分治算法回溯算法贪心算法动态规划迭代法穷举搜索法其他算法海量数据处理参考资料网页书籍刷题必备\n《剑指offer》\n《编程之美》\n《编程之法:面试和算法心得》  \n《算法谜题》 都是思维题\n《代码随想录》\n\n基础\n《数据结构与算法分析》\n《编程珠玑》Programming Pearls\n《编程珠玑(续)》\n《Algorithms》 这本近千页的书只有6章,其中四章分别是排序，查找，图，字符串，足见介绍细致\n\n算法设计\n《算法设计与分析基础》\n《算法引论》 告诉你如何创造算法 断货\n《Algorithm Design Manual》算法设计手册 红皮书\n《算法导论》 是一本对算法介绍比较全面的经典书籍\n《Algorithms on Strings,Trees and Sequences》\n《Advanced Data Structures》 各种诡异高级的数据结构和算法 如元胞自动机、斐波纳契堆、线段树 600块\n\n延伸阅读\n《深入理解计算机系统》\n《TCP/IP详解三卷》\n《UNIX网络编程二卷》\n《UNIX环境高级编程：第2版》\n《The practice of programming》 Brian Kernighan和Rob Pike\n《writing efficient programs》 优化\n《The science of programming》 证明代码段的正确性 800块一本\n\n","categories":["笔记"],"tags":["学习笔记","数据结构","算法"]}]